---
layout: post
title: "Allele-specific RNA-seq pipeline using Gsnap and GATK"
author: ericminikel
date: 2013-08-26 21:10:27
---
<p><strong>motivation</strong></p>
<p>I have some mRNA-seq data I&#8217;ve aligned with <a href="http://research-pub.gene.com/gmap/">Gsnap</a>, called expression levels (FPKMs) using <a href="http://cufflinks.cbcb.umd.edu/">Cufflinks</a>, <a title="Gene expression analysis QC pipeline in R" href="/2013/08/23/gene-expression-analysis-qc-pipeline-in-r/">QCed</a> and done a traditional gene expression analysis on. Then a very specific question came up: is one allele of <a href="http://en.wikipedia.org/wiki/Huntingtin">huntingtin</a> (HTT) more highly expressed than the other?  We hadn&#8217;t originally set out to do genome-wide allele-specific gene expression and have not genotyped all of the individuals included in the RNA-seq samples.  But we do know the HTT haplotypes for all of these individuals, so I figured it should be simple enough to figure out if one allele was overrepresented.</p>
<p>I Googled &#8220;allele-specific RNA-seq&#8221; and found an assortment of relevant tools such as <a href="http://alleleseq.gersteinlab.org/">AlleleSeq</a> and <a href="http://www.bios.unc.edu/~weisun/software/asSeq.htm">asSeq</a>, and relevant papers [e.g. <a href="http://www.ncbi.nlm.nih.gov/pubmed/21873452">Skelly 2011</a>, <a href="http://www.ncbi.nlm.nih.gov/pubmed/23919664">Stevenson 2013</a>].  However what I really needed was a simple, flexible Unix pipeline that could help me figure out how to use basic tools to answer my specific question even though I don&#8217;t have separate genome-wide SNP data.  I didn&#8217;t find that, so here it is.</p>
<p>Major disclaimer: this is <em>not</em> a comprehensive pipeline for doing a full-on allele-specific analysis.  It&#8217;s just a few steps to let you calculate the allelic balance at SNPs of interest based on your RNA-seq data.  Depending on your needs, it might be enough, and if you neither have large n nor have previously haplotyped your samples, it might be just about all you can do.</p>
<p><strong>overview</strong></p>
<p>The basic idea here is to align <a href="http://en.wikipedia.org/wiki/FASTQ_format">FASTQ</a> reads with <a href="http://research-pub.gene.com/gmap/">Gsnap</a> and then call SNPs with <a href="http://www.broadinstitute.org/gatk/">GATK</a>, producing a <a href="http://vcftools.sourceforge.net/specs.html">VCF</a> which you&#8217;ll analyze in <a href="http://www.r-project.org/">R</a>. (You&#8217;ll also need <a href="http://samtools.sourceforge.net/">samtools</a> for some intermediate steps).</p>
<p>GATK, unlike <code>samtools mpileup</code>, lists the reference and alternate <a href="http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_sting_gatk_walkers_annotator_DepthPerAlleleBySample.html">allelic depths</a> (AD) in the VCFs it produces, which is a very useful thing indeed.   After you call SNPs you can look in the VCF for SNPs you&#8217;re interested in and see if the allelic balance departs from 50/50.  Be warned that unless you have a lot of SNPs and a lot of samples, or a case of pretty extreme allele-specific expression, it&#8217;s going to be fairly hard to figure out if any AD differences represent a biological difference or just chance variation.</p>
<p><strong>step 1. prep the GATK reference for Gsnap</strong></p>
<p>GATK is finnicky.  In fact, the folks behind GATK have actively engineered it to <em>not</em> work with any reference genome FASTA files that aren&#8217;t sorted in GATK&#8217;s preferred order, an approach <a href="http://gatkforums.broadinstitute.org/discussion/1204/what-input-files-does-the-gatk-accept">they themselves describe as &#8220;draconian&#8221;</a>.  To get GATK to call SNPs on your RNA-seq data, your safest bet is to align against the reference in <a href="http://gatkforums.broadinstitute.org/discussion/1213/what-s-in-the-resource-bundle-and-how-can-i-get-it">GATK&#8217;s own resource bundle</a>, available on <a href="http://gatkforums.broadinstitute.org/discussion/1215/how-can-i-access-the-gsa-public-ftp-server">Broad&#8217;s GSA server</a>.</p>
<p>As of today the latest bundle version is 2.5 and I&#8217;m using hg19, so the files I need are here: <a href="ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/2.5/hg19/">ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/2.5/hg19/</a></p>
<p>To download, <a href="http://en.wikipedia.org/wiki/MD5">md5</a> it and gunzip it all in Unix (borrowed from my <a href="/2012/09/19/exome-sequencing-pipeline-using-gatk/">exome pipeline</a>):</p>
<pre>wget -r ftp://gsapubftp-anonymous@ftp.broadinstitute.org/bundle/2.5/hg19/ # download all files in this directory
ls *.md5 | awk '{print "sed -i \x27s|/humgen/gsa-scr1/pub/bundle/2.5/hg19/||\x27 " $0}' | bash  # replace the absolute paths in all the md5 files
ls *.md5 | awk '{print "md5sum -c " $0}' | bash # check all the md5sums - if any are not 'OK' then stop here.
gunzip *.gz</pre>
<p>And then use <code>gmap_build</code> to create a Gsnap index on this reference (see <a href="http://research-pub.gene.com/gmap/src/README">README</a> for instructions):</p>
<pre>gmap_build -d hg19_gatk -k 15 -s none gatk-bundle-2.5-hg19/ucsc.hg19.fasta</pre>
<p>This took about 20 minutes.</p>
<p>It is incredibly important that you include the <code>-s none</code> parameter, which turns off sorting.  Otherwise Gsnap will re-sort the chromosomes in the reference, thus causing GATK to later refuse to process the BAMs created by Gsnap.</p>
<p>After you run this command, you&#8217;ll find the directory in which you ran it curiously devoid of any newly-created Gsnap index.  That&#8217;s because Gsnap puts indices in its own database directory, not the directory where you run the command.  Gsnap doesn&#8217;t seem to have a command for finding out what this directory is, but if all goes smoothly you won&#8217;t need to find it anyway.</p>
<p><strong>step 2 (optional). subset your reads</strong></p>
<p>This pipeline should work fine on whole FASTQs.  But in my case I&#8217;d already aligned my reads once &#8211; just not to a GATK-compatible reference.  So I needed to realign, but I knew I only cared about allele-specific expression for one gene, HTT, located at <a href="http://genome.ucsc.edu/cgi-bin/hgTracks?hgHubConnect.destUrl=..%2Fcgi-bin%2FhgTracks&amp;clade=mammal&amp;org=Human&amp;db=hg19&amp;position=chr4%3A3076408-3245687&amp;hgt.positionInput=HTT+%28Homo+sapiens+huntingtin+%28HTT%29%2C+mRNA.%29&amp;hgt.suggestTrack=knownGene&amp;Submit=submit&amp;hgsid=345113397&amp;hgFind.matches=uc021xkv.1&amp;knownGene=pack">chr4:3076408-3245687</a>.  If you have similar needs, you can save a LOT of time by only looking at the region of interest and not the whole genome.</p>
<p>I subsetted my already-aligned BAMs with <a href="http://samtools.sourceforge.net/samtools.shtml">samtools</a> view and decomposed the (paired-end) BAMs back to (single-end) FASTQs with a modified version of <a href="/2013/07/04/how-to-convert-sam-to-fastq-with-unix-command-line-tools/">this brute-force command line approach</a>:</p>
<pre>for i in {01..24}
do
    samtools view srtd/MGH$i.bam chr4:3076408-3245687 | awk 'NR%2==1 {print "@"$1"_1\n"$10"\n+\n"$11}' &gt; $outdir/MGH$i.fastq 
    samtools view srtd/MGH$i.bam chr4:3076408-3245687 | awk 'NR%2==0 {print "@"$1"_2\n"$10"\n+\n"$11}' &gt;&gt; $outdir/MGH$i.fastq
done</pre>
<p>This took just a few seconds per each of my 24 samples (note that the input BAMs do have to already be sorted and indexed).  This gave me one ~2-3MB FASTQ per sample, as opposed to the several GB paired-end FASTQs I&#8217;d started with. This makes the downstream steps run in seconds rather than hours.</p>
<p><strong>step 3. align with Gsnap</strong></p>
<p>Now that you&#8217;ve got FASTQs and an indexed reference for Gsnap, you&#8217;re ready to align.  I align into SAM format and pipe the output directly to samtools view for compression, then use samtools sort and index since GATK will require this for the next step.</p>
<pre>for i in {01..24}
do
    gsnap --format=sam --read-group-id=RGUNKNOWN --read-group-name=MGH$i --read-group-library=LBUNKNOWN --read-group-platform=illumina -N 1 -m 10 -d hg19_gatk $outdir/MGH$i.fastq | samtools view -Sbh - &gt; MGH$i.bam
    samtools sort MGH$i.bam MGH$i.srtd
    samtools index MGH$i.srtd.bam
done</pre>
<p>This took about 1 or 2 minutes per sample.  Remember I&#8217;m working with very small files though.  When I&#8217;ve previously run Gsnap on 40M pairs of 50bp reads, it&#8217;s taken about 100 hours.</p>
<p>Note the use of <code>-d hg19_gatk</code> to specify the reference index we just created in step 1.  <code>-N 1</code> specifies &#8220;yes, do look for novel splice sites&#8221; and <code>-m 10</code> specifies a maximum of 10 mismatches.  I&#8217;m not enough of an RNA-seq expert to comment on whether these are necessarily the right settings to use, that&#8217;s just what I have in my pipeline for now.</p>
<p><strong>step 4. call SNPs with GATK</strong></p>
<p>Now it&#8217;s time to pile up the 24 BAMs I created in the last step and joint call variants on all of them using GATK&#8217;s <a href="http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_sting_gatk_walkers_genotyper_UnifiedGenotyper.html">UnifiedGenotyper</a>.</p>
<pre>java -jar /data/talkowski/tools/local/src/GenomeAnalysisTK-2.4-9-g532efad/GenomeAnalysisTK.jar \
   -R /data/HD/dataset/gatk-bundle-2.5-hg19/ucsc.hg19.fasta \
   -T UnifiedGenotyper \
   -I MGH01.srtd.bam -I MGH02.srtd.bam -I MGH03.srtd.bam -I MGH04.srtd.bam -I MGH05.srtd.bam -I MGH06.srtd.bam -I MGH07.srtd.bam -I MGH08.srtd.bam -I MGH09.srtd.bam -I MGH10.srtd.bam -I MGH11.srtd.bam -I MGH12.srtd.bam -I  -I MGH13.srtd.bam -I MGH14.srtd.bam -I MGH15.srtd.bam -I MGH16.srtd.bam -I MGH17.srtd.bam -I MGH18.srtd.bam -I MGH19.srtd.bam -I MGH20.srtd.bam -I MGH21.srtd.bam -I MGH22.srtd.bam -I MGH23.srtd.bam -I MGH24.srtd.bam \
   -L chr4:3076408-3245687 \
   --dbsnp /data/HD/dataset/gatk-bundle-2.5-hg19/dbsnp_137.hg19.vcf \
   -o all.htt.vcf \
   -stand_call_conf 50.0 \
   -stand_emit_conf 10.0 \
   -U ALLOW_N_CIGAR_READS</pre>
<p>This ran in just a few minutes.  Some notes:</p>
<ul>
<li><code>-R</code> specifies the FASTA reference genome.  This has to be the exact same file you used to create the Gsnap index in step 1.</li>
<li><code>-I</code> lists the BAM files to pile up.  If your BAMs are numbered sequentially like mine, then you can generate a list like this with a loop something like this: <code>for i in {01..24}; do     echo -n "-I MGH$i.srtd.bam "; done</code></li>
<li><code>-L</code> specifies the genomic region in which to call variants, chosen here to match the range I subsetted into my BAMs.  Even if you&#8217;ve subsetted your BAMs, using -L still speeds up UnifiedGenotyper by a factor of 10 or 100.  If you <em>don&#8217;t</em> do this, GATK will waste time looking at regions where no BAMs even have coverage.  Even if you&#8217;re doing genome-wide SNPs and not just one gene, you might consider specifying a bed file of known transcripts or known exons.</li>
<li><code>--dbsnp</code> specifies the dbsnp file in the same resource bundle where we got the reference genome FASTA file.  If you specify this, you&#8217;ll get dbSNP ids (rsids) for the SNPs that GATK calls.</li>
<li><strong>UPDATE 2014-01-22:</strong> Added <code>-U ALLOW_N_CIGAR_READS</code> to allow this command line to work with newer GATK versions which check for N in CIGAR strings. Not sure if this is the best way to handle this; there are two options, according to the below error message which I got when I ran GATK without this:
<pre>##### ERROR MESSAGE: Unsupported CIGAR operator N in read H7452ADXX130828:1:1211:19750:84317 at 1:30027. Perhaps you are trying to use RNA-Seq data? While we are currently actively working to support this data type unfortunately the GATK cannot be used with this data in its current form. You have the option of either filtering out all reads with operator N in their CIGAR string (please add --filter_reads_with_N_cigar to your command line) or assume the risk of processing those reads as they are including the pertinent unsafe flag (please add -U ALLOW_N_CIGAR_READS to your command line). Notice however that if you were to choose the latter, an unspecified subset of the analytical outputs of an unspecified subset of the tools will become unpredictable. Consequently the GATK team might well not be able to provide you with the usual support with any issue regarding any output</pre>
</li>
</ul>
<p><strong>step 5. analysis</strong></p>
<p>At this point you&#8217;ve got a VCF file, in my case <code>all.htt.vcf</code>, with variant calls in your region of interest for all of your samples.  Most of these variant calls will be extremely low quality, for two reasons.</p>
<p>First, though the libraries submitted for mRNA-seq are supposed to be enriched for mRNAs via polyA selection (or ribozero depletion of rRNA and so on), some amount of immature pre-mRNA usually creeps in. That means that you&#8217;ll get, say, 100x coverage of exons but you&#8217;ll also still get 5x or 10x coverage of introns.  Introns make up most of the gene and (at least in HTT, where evolution seems to have tolerated almost no variation at all in the coding sequence) an even larger fraction of the SNPs.  Yet your 5x or 10x coverage of introns is not deep enough to reliably call SNPs.</p>
<p>Second, RNA degrades quickly, and so polyA selection may catch the 3&#8242; end of an mRNA that&#8217;s already breaking down, meaning some portion of the 5&#8242; end has already been lost.  As a result, mRNA-seq coverage (at least when polyA selection protocols have been used) is deeper at the 3&#8242; end of genes and can get pretty sparse at the 5&#8242;.</p>
<p>As an example of both of these phenomena, here&#8217;s a coverage plot of HTT in human breast tissue from <a title="Tissue-specific gene expression data based on Human BodyMap 2.0" href="/2013/07/11/tissue-specific-gene-expression-data-based-on-human-bodymap-2-0/">Human BodyMap 2.0</a>. Exons are in blue and introns in black.  Note the ~250x coverage at the 3&#8242;UTR (far right) trailing off to ~10x by the time you get to the 5&#8242;UTR (far left), and the variable coverage of introns in black between the blue spikes of exonic coverage.</p>
<p><a href="/wp-content/uploads/2013/08/full-htt.GRCh37.HumanBodyMap.breast.1.bam_.cov_.png"><img class="alignnone size-full wp-image-2799" alt="full-htt.GRCh37.HumanBodyMap.breast.1.bam.cov" src="/wp-content/uploads/2013/08/full-htt.GRCh37.HumanBodyMap.breast.1.bam_.cov_.png"/></a></p>
<p>For both of these reasons, it&#8217;s probably unwise to do any analysis on the <i>full</i> set of SNPs that you get out of GATK.  The QUAL field gives the PHRED-scaled probability of there not actually being a SNP in any sample at each site, so P(no actual SNP here) = 1 &#8211; 1/QUAL, i.e. QUAL = 10,000 means 99.99% certainty there’s really a SNP.  See <a href="http://gatkforums.broadinstitute.org/discussion/1268/how-should-i-interpret-vcf-files-produced-by-the-gatk">description of VCF fields</a>.  You could filter on QUAL, or FILTER, or you could just use known SNPs of interest.  I’ll present here an approach in R using the QUAL field.</p>
<p>In this approach I cast the VCF to a matrix, <code>melt</code> it into relational form with three columns (dbSNP id, sample id, and value) and then use <code>sapply</code> and <code>strsplit</code> to parse the value field to yield <a href="http://www.broadinstitute.org/gatk/gatkdocs/org_broadinstitute_sting_gatk_walkers_annotator_DepthPerAlleleBySample.html">allelic depth</a> (AD) for the ref and alt alleles.  A weakness of this code is that it’s very difficult to make the <code>sapply</code>/<code>strsplit</code> combination robust to invalid values. GATK leaves the value field as simply <code>./.</code> for uncalled genotypes, which makes <code>strsplit</code> throw errors, but these functions have no equivalent of <code>na.rm</code>, and the solutions I found online &#8211; <a href="http://stackoverflow.com/questions/2269084/handling-na-values-in-apply-and-unique">this</a>, <a href="http://stackoverflow.com/questions/6499905/ignore-nas-in-sapply-function">this</a> and <a href="http://stackoverflow.com/questions/14463386/adding-na-rm-to-sapply-when-calculating-median">this</a> &#8211; don’t work for this specific use case.  Therefore I just had to play around with the QUAL threshold until I set it high enough that, for every variant meeting that threshold, all 24 of my samples had a genotype call.  If you have hundreds of samples, this approach might not work for you without some modification &#8211; I welcome any suggestions.</p>
<p>First I removed the extraneous header information from the VCF in bash and changed #CHROM to CHROM to make the column names R-friendly:</p>
<pre>cat all.htt.vcf | grep -v ^## | sed 's/^#CHROM/CHROM/' &gt; headerless.vcf</pre>
<p>Then I ran this R script:</p>
<div class="highlight" style="background: #f8f8f8;">
<pre style="line-height: 125%;"><span style="color: #408080; font-style: italic;"># cat all.htt.vcf | grep -v ^## | sed 's/^#CHROM/CHROM/' &gt; headerless.vcf</span>

library(reshape) <span style="color: #408080; font-style: italic;"># for melt</span>
options(stringsAsFactors<span style="color: #666666;">=</span><span style="color: #008000; font-weight: bold;">FALSE</span>)
setwd(<span style="color: #ba2121;">'c:/sci/026rplcl/data/rna/allele-spec/'</span>)

qual_threshold <span style="color: #666666;">=</span> <span style="color: #666666;">3000</span> <span style="color: #408080; font-style: italic;"># for me this was the lowest I could set it without including any no-call genotypes</span>
vcf <span style="color: #666666;">=</span> read.table(<span style="color: #ba2121;">'headerless.vcf'</span>,header<span style="color: #666666;">=</span><span style="color: #008000; font-weight: bold;">TRUE</span>) 
dim(vcf[vcf$QUAL <span style="color: #666666;">&gt;</span> qual_threshold, <span style="color: #666666;">1</span>:<span style="color: #666666;">9</span>]) <span style="color: #408080; font-style: italic;"># check the number of remaining SNPs after filtering</span>

mat <span style="color: #666666;">=</span> as.matrix(vcf[vcf$QUAL <span style="color: #666666;">&gt;</span> qual_threshold, <span style="color: #666666;">10</span>:<span style="color: #666666;">33</span>]) <span style="color: #408080; font-style: italic;"># cast the value portion of the VCF to a matrix</span>
dim(mat)
rownames(mat) <span style="color: #666666;">=</span> vcf$ID[vcf$QUAL <span style="color: #666666;">&gt;</span> qual_threshold] <span style="color: #408080; font-style: italic;"># re-apply the row names</span>

rel <span style="color: #666666;">=</span> melt(mat) <span style="color: #408080; font-style: italic;"># melt matrix to a 3-column relational table</span>
dim(rel)
colnames(rel) <span style="color: #666666;">=</span> c(<span style="color: #ba2121;">"ID"</span>,<span style="color: #ba2121;">"SAMPLE"</span>,<span style="color: #ba2121;">"VALUE"</span>)

rel$AD <span style="color: #666666;">=</span> sapply(strsplit(rel$VALUE,<span style="color: #ba2121;">":"</span>),<span style="color: #ba2121;">"[["</span>,<span style="color: #666666;">2</span>) <span style="color: #408080; font-style: italic;"># parse allelic depth (AD) from value field</span>
rel$REFAD <span style="color: #666666;">=</span> as.integer(sapply(strsplit(rel$AD,<span style="color: #ba2121;">","</span>),<span style="color: #ba2121;">"[["</span>,<span style="color: #666666;">1</span>)) <span style="color: #408080; font-style: italic;"># parse REF allele depth from AD</span>
rel$ALTAD <span style="color: #666666;">=</span> as.integer(sapply(strsplit(rel$AD,<span style="color: #ba2121;">","</span>),<span style="color: #ba2121;">"[["</span>,<span style="color: #666666;">2</span>)) <span style="color: #408080; font-style: italic;"># parse ALT allele depth from AD</span>
rel$ARATIO <span style="color: #666666;">=</span> rel$ALTAD <span style="color: #666666;">/</span> (rel$REFAD <span style="color: #666666;">+</span> rel$ALTAD) <span style="color: #408080; font-style: italic;"># calculate allelic ratio (% reads supporting ALT allele)</span>

rel$BP <span style="color: #666666;">=</span> as.integer(vcf$POS[match(rel$ID,vcf$ID)])
plot(rel$BP, rel$ARATIO, pch<span style="color: #666666;">=19</span>, xlab<span style="color: #666666;">=</span><span style="color: #ba2121;">'chr4 BP'</span>, ylab<span style="color: #666666;">=</span><span style="color: #ba2121;">'ALT allele depth as fraction of total'</span>, main<span style="color: #666666;">=</span><span style="color: #ba2121;">'Allelic balance at HTT SNPs'</span>)
abline(h<span style="color: #666666;">=.5</span>)</pre>
</div>
<p>The result is a plot like this, showing the allelic balance for the various samples at each variant site.</p>
<p><a href="/wp-content/uploads/2013/08/allelic.balance.htt_.snps_.fakedata.png"><img class="alignnone size-full wp-image-2800" alt="allelic.balance.htt.snps.fakedata" src="/wp-content/uploads/2013/08/allelic.balance.htt_.snps_.fakedata.png"/></a></p>
<p>This by itself probably isn&#8217;t that informative, since it doesn&#8217;t reflect phasing &#8211; the y axis is always the percentage of the ALT allele, even though a person&#8217;s ALT allele at one SNP may be on the opposite haplotype as their ALT allele at another SNP.  But at least, this sort of plot is a first glance at the data and may help you decide how far to pursue this &#8211; if the allelic balance of every SNP is very tightly clustered around 50/50, odds are against you finding any interesting allele-specific patterns.  If the spread is larger and worth looking into, then how you do the downstream analysis will depend on how you have got your haplotype data structured.</p>
<p>That&#8217;s all I&#8217;ve got &#8211; this isn&#8217;t the <em>right</em> way to do allele-specific expression, but if your dataset&#8217;s already been created and the question is just whether you can answer a specific question with it, hopefully this will be helpful.</p>
